#!/usr/bin/python

import sys, signal, optparse, time

from   ldui.logreader import LogReader
from   ldui.common    import LogDateError, LogMissingError
from   dpkt.ip        import IP_PROTO_TCP, IP_PROTO_UDP

# globals
log_reader     = None
proto_names    = { IP_PROTO_TCP : 'tcp', IP_PROTO_UDP : 'udp' }
commands       = (  )

def usage():
    query = "query - show all 'log' entries or [ports, dest] per binary"
    txt   = "usage: %sprog [options] query\n\n%s" % ( '%', query )

    return txt

def print_log(raw):
    '''Print the entire log'''
    if not raw:
        print "%-5s %-10s %-6s %-6s %-16s %-7s %24s %s" % ( 'id', 'user', 'proto', 'dport', 'dest', 'outcome', 'date', 'binary' )

    for log in log_reader.get_all():
        if raw:
            print repr(log)
        else:
            print "%-5s %-10s %-6s %-6s %-16s %-7s %24s %s" % ( log['id'], log['user'], log['proto'], log['dport'],
                                                                log['dest'], log['outcome'], log['date'], log['bin'] )

def print_ports(raw):
    '''Print the ports per binary'''
    protos = log_reader.get_ports()

    if raw:
        print repr(protos)
        return
    else:
        print "%5s %5s %5s %s"  % ( 'proto', 'port', 'count', 'binary' )

    for ( proto, ports ) in protos.iteritems():
        for port in sorted(ports):
            bins = ports.get(port)
            b    = sorted(bins, key=bins.__getitem__).pop()

            print "%5s %5s %5s %s"  % ( proto_names[proto], port, bins.pop(b), b )

            for binary in sorted(bins, key=bins.__getitem__, reverse=True):
                print "%17s %s" % ( bins.get(binary), binary )

def print_dest(raw):
    '''Print the destinations per binary'''
    binaries = log_reader.get_dest()
    for ( path, dests ) in binaries.iteritems():
        if raw:
            print repr(path)
            print repr(dests)
        else:
            for ( dest, protos ) in dests.iteritems():
                print "%16s %s" % ( dest, path )
                for ( proto, ports ) in protos.iteritems():
                    ( p, c ) = ports.popitem()
                    print "%10s %5s %5s"  % ( proto_names[proto], p, c )
                    for ( port, count ) in ports.iteritems():
                        print "%16s %5s" % ( port, count )

def sigint_handler(signal, frame):
    ''' Clean up on close
    '''
    sys.exit(0)

curr_date = time.localtime()
parser    = optparse.OptionParser(usage=usage())
parser.add_option('-y', '--year',
                  dest='year', default=curr_date.tm_year, type=int,
                  help='log yeari (yy, default=current year)')
parser.add_option('-m', '--month',
                  dest='month', default=curr_date.tm_mon, type=int,
                  help='log month (mm, default=current month)')
parser.add_option('-d', '--day',
                  dest='day', default=curr_date.tm_mday, type=int,
                  help='log day (dd, default=today)')
parser.add_option('-r', '--raw',
                  dest='raw', default=False, action='store_true',
                  help='Output raw data')
parser.add_option('-b', '--base',
                  dest='base', default='.',
                  help='base install directory')

options = ""
args    = ""

if __name__ == '__main__':
    (options, args) = parser.parse_args()
    signal.signal(signal.SIGINT, sigint_handler)

    try:
        log_reader = LogReader("%s/log" % options.base, (str(options.year), str(options.month), str(options.day)))
    except LogDateError as e:
        sys.stderr.write("%s\n" % e.msg)
        sys.exit(1)
    except LogMissingError as e:
        sys.stderr.write("%s\n" % e.msg)
        sys.exit(2)

    if len(args) != 0 and args[0] not in ( 'log', 'ports', 'dest' ):
        sys.stderr.write("query must be log, ports or dest\n")
        sys.exit(3)
    elif len(args) == 0:
        args.append('log')

    # run command given as argument or show all logs per default
    globals()['print_%s' % args[0]](options.raw)
